---
title: 쿠버네티스에서의 네트워크는 어떻게 작동할까 - 파드
date: 2024-01-17
categories: ["KUBENETES", "NETWORK"]
tags: ['kubenetes', 'network']      # TAG names should always be lowercase
toc: true
---

쿠버네티스를 사용하다 보면 당연스럽게 생각되는게 있다.
1. POD안에 있는 컨테이너들은 localhost를 통해 서로 통신할수 있다.
2. POD끼리의 통신은 NAT없이 flat하게 가능하다.

이게 어떻게 가능한지 정리해보자

## 1번 질문에 대한 답: **Pause container**

컨테이너가 하나만 있는 파드를 생성한다고 했을때 kubelet은 컨테이너를 하나만 실행하지 않는다. kubelet은 파드 명세에 적혀있는 컨테이너들을 실행하기 전에 먼저 실행하는 컨테이너가 있는데, 그게 `pause 컨테이너`이다. 

pause 컨테이너는 아무런 동작도 하지 않는다. pause 컨테이너는 앞으로 생성될 컨테이너들이 사용할 네트워크 네임스페이스와 PID 네임스페이스를 설정한다. 그 이후에 실행되는 컨테이너들은 pause 컨테이너의 네트워크 네임스페이스와 PID 네임스페이스를 상속받는다.
> 사실 잘못 서술한 것이 있는데, kubelet은 컨테이너를 `실제로 실행하진 않는다.` 컨테이너를 실행하는 것은 내부적으로 CRI의 일이다. 
{: .prompt-warning }

이를 통해 파드내의 컨테이너들은 같은 네트워크 네임스페이스와 인터페이스를 공유하게되며, 이를 통해 파드안에 있는 컨테이너들은 localhost를 통해 서로 통신할수 있게된다.
> pause 컨테이너의 라이프사이클은 파드의 라이프사이클과 동일하기 때문에 파드가 실행중일때는 같이 계속 실행된다.
{: .prompt-info}

## 2번 질문에 대한 답: 노드내의 네트워크 브리지 

Pause container가 시작되기 전에, 컨테이너를 위한 가상 이더넷 인터페이스 쌍(veth...)이 생성된다. 한쪽 인터페이스는 호스트의 네임스페이스에 남아있고, 다른쪽 인터페이스에는 컨테이너의 네트워크 네임스페이스 안으로 옮겨져 이름이 eth0으로 변경된다. `한마디로 호스트의 네트워크 네임스페이스와 컨테이너의 네트워크 네임스페이스가 연결된다.` 

이렇게 연결된 호스트의 네트워크 네임스페이스에 있는 인터페이스는 컨테이너 런타임이 사용할 수 있도록 설정된 `네트워크 브리지`에 연결되고, 컨테이너 안의 eth0 인터페이스는 브리지의 주소 범위 안에서 IP를 할당받는다. 

파드 A의 veth(eth0로 이름이 변경됨) - 호스트의 veth0 - 네트워크 브리지(10.1.1.0/24)

이렇게 같은 노드안에 파드들이 많이 생성되면, 같이 공유하는 네트워크 브리지를 통해서 파드끼리의 통신이 가능하다. 
> 여기서 만약 3계층 장비를 사용하고, 노드내부의 네트워크 브리지와 노드의 물리적 네트워크 인터페이스를 연결한다면, 다른 노드에 속해있는 파드끼리의 통신도 flat하게 가능해진다. 
{: .prompt-info}